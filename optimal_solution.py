# -*- coding: utf-8 -*-
"""ai_assign1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19w1fJ4OetDiWhCsthLBZ6elZsCCTAqvO
"""

from itertools import combinations
import math
from copy import deepcopy
#importing the necessary classes

class Coordinates():
  def __init__(self, x, y):
    self.x = x
    self.y = y
    #initializing to the start points as generated

  def collision(self, other):
    return self.x == other.x and self.y == self.y

class State():
  def __init__(self, time, location):
    self.time = time
    self.location = location

  def same_place_different_day(self, other):
    return self.location.x == other.location.x and self.location.y == other.location.y

  def vertexconstraint(self, other): #we are taking both time and location into consideration here
    return self.location == other.location and self.time == other.time

class Conflicts():

  def __init__(self):
    self.time = -1
    self.method = ''
    
    self.robot1 = ''
    self.robot2 = ''

    self.loc1 = Coordinates(-1, -1)
    self.loc2 = Coordinates(-1, -1)
    #this is used to store what type of conflict exists between which two robots


  def __hash__(self):
    return hash(str(self.time) + str(self.method) + str(self.robot1) + str(self.robot2) + \
                str(self.loc1) + str(self.loc2)) #returns all the member variables of the object

class VertexConstraint():
  def __init__(self, time, location):
    self.time = time
    self.location = location

  def collision(self, other): #we are taking both time and location into consideration here
    return self.location == other.location and self.time == other.time

class EdgeConstraint():
  def __init__(self, time, point1, point2):
    self.time = time
    self.point1 = point1
    self.point2 = point2

  def collision(self, other):
    #we check if, according to their paths, they are scheduled to traverse the same edge at the same time
    return self.time == other.time and self.point1 == other.point1 and self.point2 == other.point2

class Constraints():
  #this class is for storing all those constraints, which we need for defining the problem
  def __init__(self):
    self.vertexconstraints = set()
    self.edgeconstraints = set()

  def addingconstraints(self, other):
    self.vertexconstraints |= other.vertexconstraints
    self.edgeconstraints |= other.edgeconstraints
    #as one robot is bound by the positions the other one occupies


  def __str__(self):
      return "VC: " + str([str(vc) for vc in self.vertex_constraints])  + \
          "EC: " + str([str(ec) for ec in self.edge_constraints])

class HighLevelNode():
    def __init__(self):
        self.solution = {}
        self.constraint_dict = {}
        self.cost = 0

class PathPlanning():
  def __init__(self, rows, columns, start, goal, noofrobots, obstacles,tempstorage):
    self.rows = rows
    self.columns = columns
    #this is called at the beginning when we define a matrix 

    self.obstacles = obstacles

    self.tempstorage = tempstorage
    
    '''
    start and goal are a list of coordinates of the start and goal points for each robot
    thus, we need to find the basic search solution for each robot using these, and store in a list
    
    '''

    self.start = start
    self.goal = goal

    #noofrobots is an int which stores the number of robots

    self.noofrobots = noofrobots
    
    self.names = []

    for i in range(1, noofrobots + 1):
      self.names.append("Robot " + str(i))

    #generating a list of robot names 
    self.agent_dict = {}
    self.make_agent_dict() 

    self.constraints = Constraints()
    self.constraintdict = {}
    #creating an empty dictionary for all the constraints

  def validstate(self, state):
    return state.location.x >= 0 and state.location.x <= self.rows and \
    state.location.y >= 0 and state.location.y <= self.columns and \
    (state.location.x, state.location.y) not in self.obstacles \
    and ((VertexConstraint(state.time, state.location) not in self.constraints.vertexconstraints) or \
         ((state.location.x, state.location.y) in self.tempstorage or self.start or self.goal))

    '''
    basically all those conditions that make a state valid, within the dimensions, not an obstacle
    and also not a state which is occupied by another robot at the same time instance

    The next part tries to find out if, according to the solution obtained, more than one robot
    has two consecutive states the same at the same timestamp. Such a case would imply an edge collision.

    '''
  def validedge(self, state1, state2):
    return EdgeConstraint(state1.time, state1.location, state2.location) not in self.constraints.edgeconstraints

  def validmovements(self, state):
    val = list()
      #to store the surrounding states which can be occupied

    n = []  

    n = [State(state.time + 1, Coordinates(state.location.x, state.location.y)), \
        State(state.time + 1, Coordinates(state.location.x, state.location.y+1)), \
        State(state.time + 1, Coordinates(state.location.x, state.location.y-1)), \
        State(state.time + 1, Coordinates(state.location.x+1, state.location.y)), \
        State(state.time + 1, Coordinates(state.location.x-1, state.location.y))]
    #creating a list of objects of the surrounding neighbours


    for i in n:
      if self.validstate(i) and self.validedge(state, i):
        val.append(i)

    return val
    #returning the valid surrounding coordinates  


  def currentstate(self, name, solution, time):
    if time < len(solution[name]):
      return solution[name][time]
    else:
      return solution[name][-1]

  '''
  We assume that unit time is taken for a one step movement from one node to another.
  Thus, the total time will be equal to the length of the path

  We then try to see if the time at which the state is to be located is before the total time or not

  If yes, then we return that particular state

  If the time at which the state is desired exceeds the maximum time, then it is safe to assume 
  that the robot has reached the final destination. Thus, we can say that the current state will be 
  its goal, which is the same as the final node in its path (and thus indexed -1)
  
  '''       


  def findCollision(self, solution):
    tm = max([len(i) for i in solution.values()])
    #finding the largest path so that we can take all possible pairs into consideration

    res = Conflicts()
    #class which stores log-like information of the type of conflict that arises and its details

    for i in range(tm):
      for robo1, robo2 in combinations(solution.keys(), 2):
        #taking all possible nC2 combinations
        state1 = self.currentstate(robo1, solution, i)
        state2 = self.currentstate(robo2, solution, i)

        if state1.same_place_different_day(state2):
          res.time = t
          res.method = "VERTEX"
          res.loc1 = state1.loc1
          res.robot1 = robo1
          res.robot2 = robo2
          return res
      
      #this was to detect a vertex conflict, and it returns 0 for the method

      for robo1, robo2 in combinations(solution.keys(), 2):
        #taking all possible nC2 combinations
        state1i = self.currentstate(robo1, solution, i)
        state1f = self.currentstate(robo1, solution, i + 1)
        state2i = self.currentstate(robo2, solution, i)
        state2f = self.currentstate(robo2, solution, i + 1)

        if state1i.same_place_different_day(state2i) and state1f.same_place_different_day(state2f):
          res.time = t
          res.method = "EDGE"
          res.loc1 = state1.loc1
          res.loc2 = state2.loc2
          res.robot1 = robo1
          res.robot2 = robo2
          return res

      #to detect if an edge conflict happens


  def addingtoconstraints(self, conflict):
    constraints = {}
    #creating an empty dictionary
    if conflict.method == "VERTEX":
      y = VertexConstraint(conflict.time, conflict.loc1)
      constraint = Constraints()
      constraint.vertexconstraints |= {y}
      constraints[conflict.robo1] = constraint
      constraints[conflict.robo2] = constraint

    elif conflict.method == "EDGE":
      y = EdgeConstraint(conflict.time, conflict.loc1, conflict.loc2)
      z = EdgeConstraint(conflict.time, conflict.loc2, conflict.loc1)

      constraint1 = Constraints()
      constraint2 = Constraints()

      constraint1.edgeconstraints |= {y}
      constraint2.edgeconstraints |= {z}

      constraints[conflict.robo1] = constraint1
      constraints[conflict.robo2] = constraint2

    return constraints


  def make_agent_dict(self):
    for i in range(self.noofrobots):
      start_state = State(0, Coordinates(self.start[i][0], self.start[i][1]))
      goal_state = State(0, Coordinates(self.goal[i][0], self.goal[i][1]))

      self.agent_dict.update({self.names[i]:{'start':start_state, 'goal':goal_state}})
    
      #print(self.agent_dict[self.names[i]])
    
  
  def astar(self, agent_name):
      initialstate = self.agent_dict[agent_name]["start"]
      goal = self.agent_dict[agent_name]["goal"]

      step = 1 #initializing the step cost

      closed_set = set()
      open_set = set()
      open_set |= {initialstate} 
      came_from = {}

      g_score = {}
      g_score[initialstate] = 0

      f_score = {}
      f_score[initialstate] = abs(initialstate.location.x - goal.location.x) + abs(initialstate.location.y - goal.location.y)

      while open_set:
        temp_score = {open_item:f_score.setdefault(open_item, float("inf")) for open_item in open_set}
        current = min(temp_score, key = temp_score.get)
        #finding the node with the smallest score

        if current.same_place_different_day(goal):
          return self.finalpath(came_from, goal) 

        open_set -= {current}
        closed_set |= {current}
        

        '''
        moving the selected node from the open list to the closed loop

        This loop will terminate when the open set is empty.
        
        '''
        immediate = self.validmovements(current)
        
        '''
        we try to see if around the current state, and the current state at the next time instance,
        are valid states, and we try to get a list of all such states

        '''
       
        for i in immediate:
          #print(str(i.time) + " " + str(i.location.x) + " " + str(i.location.y))
          if i in closed_set:
            continue

          tentative_g_score = g_score.setdefault(current, float("inf")) + step
          #we are trying to find the score for each of the chosen nodes

          if i not in open_set:
            open_set |= {i}

            #we can add each surrounding valid state to the open set, and continue the operation

          elif tentative_g_score >= g_score.setdefault(i, float("inf")):
            continue


          came_from[i] = current
          #keeping a track of the parent of each node

          g_score[i] = tentative_g_score
          f_score[i] = g_score[i] + abs(i.location.x - goal.location.x) + abs(i.location.y - goal.location.y)
          #print(g_score[initialstate])
          #print(f_score[initialstate])


      return False

  def finalpath(self, came_from, goal):
    total_path = [goal]
    while goal in came_from.keys():
      goal = came_from[goal]
      total_path.append(goal)

    return total_path[::-1]       #as this computed part is the reverse

  def compute_solution(self):
    solution = {}
    for agent in self.agent_dict.keys():
      self.constraints = self.constraintdict.setdefault(agent, Constraints())
      local_solution = self.astar(agent)
      if not local_solution:
        return False
      solution.update({agent:local_solution})
    return solution

class CBS():
    def __init__(self, environment):
        self.env = environment
        self.open_set = set()
        self.closed_set = set()

    def search(self):
        start = HighLevelNode()
       
        start.constraintdict = {}
        for robot in self.env.agent_dict.keys():
            start.constraintdict[robot] = Constraints()
        #initializing the constraints for each robot

        start.solution = self.env.compute_solution()
        if not start.solution:
            return {}
        start.cost =  sum([len(path) for path in start.solution.values()])

        self.open_set |= {start}

        while self.open_set:
            P = min(self.open_set)
            self.open_set -= {P}
            self.closed_set |= {P}

#the stopping condition for this is that the open list becomes empty

            self.env.constraintdict = P.constraintdict
            conflictdict = self.env.findCollision(P.solution)
            if not conflictdict:
                print("solution found")
                #print("The total cost = " + str(start.cost))
                #print(P.solution.keys())
                return self.generate_plan(P.solution)
                

            constraintdict = self.env.addingtoconstraints(conflictdict)

            for agent in constraintdict.keys():
                new_node = deepcopy(P)
                new_node.constraintdict[agent].addingconstraints(constraintdict[agent])

                self.env.constraintdict = new_node.constraintdict
                new_node.solution = self.env.compute_solution()
                if not new_node.solution:
                    continue
                new_node.cost = sum([len(path) for path in new_node.solution.values()])

                if new_node not in self.closed_set:
                    self.open_set |= {new_node}

        return {}

    def generate_plan(self, solution):
        plan = {}
        for robot, path in solution.items():
            path_dict_list = [{'t':state.time, 'x':state.location.x, 'y':state.location.y} for state in path]
            #print(path_dict_list)
            plan[robot] = path_dict_list
        return plan

def main():
  
  
  print("Input the number of rows and columns")
  rows = int(input(("\nRows = ")))
  columns = int(input(("\nColumns = ")))

  o = int(input(("\nInput the number of obstacles = ")))

  #choosing a rough pattern for the start and goal states
  
  k = int(input("Enter the number of robots = "))
  ts = int(input("Enter the number of temporary storage locations = "))

  start = []
  goal = []
  temp = []
  obstacles = []
  #creating 3 empty lists

  print("Input the start and the goal points for: [as x y if the point is (x, y)]")
  
  for i in range(k):
    print("Robot " + str(i+1) + ": ")
    print("Start points:")
    x = int(input())
    y = int(input())
    if x > 0 and x < rows and y > 0 and y < columns:
      start.append([x, y])

    print("Goal points:")
    x = int(input())
    y = int(input())
    if x > 0 and x < rows and y > 0 and y < columns:
      goal.append([x, y])
    

  print("Input the temporary storage location coordinates ")

  for i in range(ts):
    x = int(input())
    y = int(input())
    if x > 0 and x < rows and y > 0 and y < columns:
      temp.append([x, y])


  print("Input the obstacle coordinates ")
  for i in range(o):
    x = int(input())
    y = int(input())
    if x > 0 and x < rows and y > 0 and y < columns:
      obstacles.append([x, y])

  pp = PathPlanning(rows, columns, start, goal, k, obstacles, temp)
  
  cbs = CBS(pp)

  solution = cbs.search()

  if not solution:
    print("No solution is found")
    return

  print(solution)
  print("The total cost = " + str(sum([len(path) for path in solution.values()])))

main()